\documentclass[conference]{IEEEtran}
\usepackage{standalone}
\usepackage{times}
\usepackage{float}
\usepackage{amsmath}

\input{TemplateFiles/def.tex}
\input{TemplateFiles/inc}

\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\X}{{\mathbb{X}}}
\newcommand{\Y}{{\mathbb{Y}}}

\newcommand{\po}{\mathbb{P}}     % Probability of an event
\newcommand{\p}[1]{\po\left(#1\right)}     % Probability of an event
\newcommand{\pd}[1]{p\left(#1\right)}     % Probability density of an event
\newcommand{\borel}[1]{\mathcal{B}\left(#1\right)}
\newcommand{\rel}{\mathcal{R}}%{A relation}
% numbers option provides compact numerical references in the text. 

\pdfinfo{
   /Author (Homer Simpson)
   /Title  (Robots: Our new overlords)
   /CreationDate (D:20101201120000)
   /Subject (Robots)
   /Keywords (Robots;Overlords)
}

% Table caption wrangling
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@makecaption}
  {\scshape}
  {}
  {}
  {}
\makeatletter
\patchcmd{\@makecaption}
  {\\}
  {.\ }
  {}
  {}
\makeatother



\allowdisplaybreaks[1]

\begin{document}

% paper title
%\title{\large From Mission Specification to Safe Control Logic Under Uncertainty:\\ Application to Mars Copter-Rover Navigation-Coordination}

\title{\huge Formal abstraction of POMDPs for Distribution LTL:\\ Can we formally deal with uncertainty?}

\author{Sofie, Petter, Cristi, Rohan, Ali Agha, Richard Murray, Aaron Ames}

\maketitle

\begin{abstract}
Currently this report mainly includes copies of the  original paper on pulled by Cristi on Temporal logics with beliefs for planning problems.  Goal is to first see how the temporal logic specifications can be defined with measurability in mind. Then we will include this in the original paper, before starting continuing with the development of this report. 
\end{abstract}

\IEEEpeerreviewmaketitle

	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\section{Introduction} \label{subsec:intro}
In this work, we use a language for specifying behavior under uncertainty using formal methods. 

Some of the questions to be tackled are as follows:
\begin{description}
	\item[Framework:] Does it make sense to formulate the DLTL on a specific choice of belief space or sufficient statistic? Can we instead first formulate it on the POMDP and then show that it  is equivalent to a problem on a COMDP?
	\item[Technical:]  What are the minimal measurability conditions that are required such that for given a POMDP and its reduced COMDP  the LTL problem is ``well"-defined (measurable).
	\item[Technical:] Beyond well-definedness, do we also keep soundness and completeness?
	\item[Technical:] When are optimal policies non-randomized?
	\item[Simulation relations]  Use $(\epsilon,\delta)$- simulation relation for doing formal abstractions on the COMDP model.
	Show that it can be used for control refinement.
	\item[Interesting:] How does system identification fit into this picture?
	\item[Simulation relations:] Can we quantify an $(\epsilon,\delta)$-simulation relation between the sampling based model and the original COMDP?
	\item[Computation results:] Improve results for the computation of $(\epsilon,\delta)$-simulation relations for LTI systems. Reformulate LMI requirement from S-procedure to requirements over Polytopes. 
	\item[Scalable computations:] Can we  tackle the computations in a modular fashion. Split up requirements for e.g. the helicopter and the rover and show that the combined system still behaves as required.
	 
\end{description}


\section{Partially observable Markov decision Processes}
In this work, we only consider  Borel measurable spaces, i.e., $(\X,\mathcal{B}(\X))$, 
%In this work,
and we restrict our attention to Polish spaces \cite{bogachev2007measure}. 
Together with the measurable space $(\X,\mathcal{B}(\X))$,  a probability measure $\po$ defines the probability space, denoted by $(\X,\mathcal{B}(\X),\po)$ and has realisations  $x\sim \po$.   
Let us further denote the set of all probability measures for a given measurable space $(\X,\mathcal{B}(\X))$ as $\mathcal P (\X,\mathcal{B}(\X))$.


 
 
The reduction of Markov decision problems with incomplete information to problems with complete information has been tackled in
\cite{yushkevich_reduction_1976,rhenius_incomplete_1974}, with respect to Borel states and Borel actions.

In \cite{feinberg2016partially} and in \cite{feinberg2014optimality} the optimality conditions for POMDP problems solved via COMDPs are analyzed. 

In \cite{saldi2017finite}, the convergence of solutions of finite abstractions of COMPDs to the optimal solutions of POMDPs is analyzed. 






\section{Belief Space Temporal Logic}

	In this section, we define a language for specifying behavior under uncertainty using formal methods. This is of particular interest for planning problems in partially-observable environments.
	 We will start by reviewing partially-observable systems and the POMDP problem. Then we will go over the belief-based temporal logic for mission planning.
	
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{POMDP}\label{sec:POMDP}
	Let us denote the system state, action, and observation at the $k$-th time-step by $x_k, u_k, z_k$, respectively. Let $x_{k+1}=f(x_k,u_k,w_k)$ and $z_k=h(x_k,v_k)$ denote the system dynamics and measurement models, where $w_k\sim p_w(\cdot|x_k)$ and $v_k\sim p_v(\cdot|x_k)$ denote the state-dependent process and observation noise.  \red{Is this by default independent noise?}
	
	
	Due to the observation noise, the best one can infer about the system state is a probability distribution over all possible states, referred to as belief $b_k=p(x_k|z_{0:k})$. Belief space (i.e., the set of all beliefs) is denoted by $\mathbb{B}$. Belief is typically evolved using a recursive filter denoted by $\tau$ as $b_{k+1}=\tau(b_k,u_k,z_{k+1})$. The control policy $\pi$ in a partially observable setting is a mapping from belief space to the action space, i.e., $u_k=\pi(b_k)$. 
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{\DTL}\label{sec:DTL}
    To encode mission specifications, and synthesize a controller to satisfy them, we resort to formal methods. To develop a language for formal planning and reasoning over the belief state, we rely on predicate-based logic.
    %\pr{Predicate-based logic vs. propositions-based logic}
    %In this work, we will rely on predicate logic because we explicitly reason about the belief of the system (e.g. covariance matrix) as opposed to proposition-based logic where the state of system is implicit in the definitions of the propositions.
    
    %a predicate temporal logic defined over the space of Gaussian distributions with fixed dimension.
    
    \pr{Notation}
    Let $\Sigma$ be a finite set. The cardinality,
    power set, Kleene- and $\omega$-closures
    of $\Sigma$ are denoted by $\card{\Sigma}$,
    $\spow{\Sigma}$, $\Sigma^*$ and $\Sigma^\omega$,
    respectively.
    $A \subseteq \BB{R}^n$ and $B \subseteq \BB{R}^m$,
    $n, m \geq 0$, we denote by $\CA{M}(A, B)$ the set of
    functions with domain $A$ and co-domain $B$, where $A$ has positive measure with
    respect to the Lebesgue measure of $\BB{R}^n$.
    The set of all positive semi-definite matrices of size
    $n \times n$, $n \geq 1$, is denoted by $S^n$.
    $\BB{E}[\cdot]$ is the expectation operator.
    The $m \times n$ zero matrix and
    the $n \times n$ identity matrix are denoted by
    $\BF{0}_{m, n}$ and $\BF{I}_n$, respectively.
    The supremum and Euclidean norms are denoted by
    $\norminf{\cdot}$ and $\normeucl{\cdot}$, respectively.
    
    \pr{Parametrized Belief space}
    In this work, we assume the belief space $\mathbb{B}$ is  a finite dimensional space and can be parameterized. For example, let $\CA{G}$ denote the Gaussian belief space
    of dimension $n$, i.e. the space of Gaussian
    probability measures over $\BB{R}^n$.
    For brevity, we identify the Gaussian measures
    with their finite parametrization, mean and
    covariance matrix. Thus,
    $\CA{G} =  \BB{R}^n \times  S^n$.
    If $\BF{b} = b^0b^1 \ldots \in \CA{G}^{\omega}$,
    we denote the suffix sequence $b^i b^{i+1} \ldots$ by
    $\BF{b}^i$, $i \geq 0$. Each member of $\Sigma^*$ and $\Sigma^\omega$ is referred to as ``word" or "sequence". 
    
    For the language grammar we will rely on Bakus-Naur form. $\True$ and $\False$ are Boolean constants that respectively describe specifications that are always satisfied or can never be satisfied. Predicate $f\leq 0$ is defined as a function $f:\mathbb{B}\rightarrow \mathbb{R}$ that encodes constraints or properties over belief space. Defining predicates over the belief space allows us to enforce properties directly on the probability distribution of the system (and hence its chance constraints). Some examples are \textbf{(i)} Bounds on determinant or trace of of the covariance matrix (i.e., $det(P)$, $Tr(P)$) to  bound the uncertainty about the system's state. \textbf{(ii)} Bound on projection of covariance matrix $\Pi P$ to bound the uncertainty in a specific direction.
    \textbf{(iii)} Bounds on state mean $\hat{x}$ to specify
    where in the state space the system should be. \textbf{(iv)} Bounds on Mahalanobis distance $\mathcal{M}(\hat{x},P,x) = (\hat{x}-x)^TP^{-1}(\hat{x}-x)$.
    to describe the distance from a point to a Gaussian distribution, when specifying a desired state (or region) in the state space. We then combine these predicates via operators to create specifications. Operators include boolean "and" $\andltl$, "or" $\orltl$, "not" $\notltl$, and temporal operators: "until" $\Until$, "eventually" $\Event$, "always" $\Always$, "next" $\Next$.
    
    %\pr{Structure of the formulae}
    %Parts of the formulae is not part of the syntax but rather ... In particular $|$ defines option. For example, $\phi::=A | B$ means specification $\phi$ can be either $A$ or $B$. Example: an arithmetic expression has the following syntax grammar $expr::= c | x | expr + expr | expr - expr | expr * expr | expr / expr$.
    
    \begin{definition}[\DTL Syntax]
    \label{def:gdtl-syntax}
    The {\em syntax} of \DTL includes the minimum number of operators to define the logic:
    \begin{equation*}
     \phi :=  \True \ |\ f \leq 0 \ |\ \notltl \phi \ |\ \phi_1 \andltl \phi_2 \ |\ \phi_1 \Until \phi_2 \ |\ \Next \phi
    \end{equation*}
    %where $\True$ is the Boolean constant ``True'',
    %$f \leq 0$ is a predicate over $\mathbb{B}$, where
    %$f \in \CA{M}(\mathbb{B}, \BB{R})$.
    %$\notltl$ is negation (``Not''), $\andltl$ is conjunction (``And''),
    %$\Next$ is ``Next'',
    %and $\Until$ is ``Until''.
    \end{definition}

    For convenience, we define the additional operators:
    $\phi_1 \orltl \phi_2 \equiv  \notltl (\notltl \phi_1 \andltl \notltl \phi_2)$,
    $\Event \phi \equiv \True \Until \phi$, and
    $\Always \phi \equiv \notltl \Event \notltl \phi$,
    %\begin{align*}
    %\phi_1 \orltl \phi_2 & \equiv  \notltl (\notltl \phi_1 \andltl \notltl \phi_2) \\
    %\LTLEVENTUALLY \phi & \equiv \True \LTLUNTIL \phi \\
    %\LTLALWAYS \phi & \equiv \notltl \LTLEVENTUALLY \notltl \phi
    %\end{align*}
    where $\equiv$ denotes semantic equivalence. \DTL syntax defines the symbols and their correct ordering to form a formulae. In the following, we define \DTL semantics, i.e., the meaning of those symbols.

    \begin{definition}[\DTL Semantics]
    \label{def:gdtl-semantics}
    Let $\BF{b} = b^0b^1 \ldots \in \mathbb{B}^{\omega}$
    be an infinite sequence of belief states. $\BF{b} \models \phi$ denotes the event that the word $\BF{b}$ satisfies specification $\phi$. Accordingly, the {\em semantics} of \DTL is defined recursively as
    \begin{align*}
    &\BF{b}^i \models  \top  & \\
    &\BF{b}^i \models f \leq 0 & \Equiv\quad & f(b^i) \leq 0\\ % \forall (x,P) \in b^i \\
    &\BF{b}^i \models \notltl \phi & \Equiv\quad & \notltl (\BF{b}^i \models \phi) \\
    &\BF{b}^i \models \phi_1 \andltl  \phi_2  & \Equiv\quad & ( \BF{b}^i \models \phi_1 ) \andltl ( \BF{b}^i \models \phi_2 ) \\
    &\BF{b}^i \models \phi_1 \orltl  \phi_2  & \Equiv\quad & ( \BF{b}^i \models \phi_1 ) \orltl ( \BF{b}^i \models \phi_2 ) \\
    &\BF{b}^i \models  \phi_1 \Until \phi_2 & \Equiv\quad & \exists j \geq i \text{ s.t. } ( \BF{b}^j \models \phi_2 ) \\
    & & & \andltl (\BF{b}^k \models \phi_1, \forall k \in \{i, \ldots j-1\})\\
    &\BF{b}^i \models \Event \phi  & \Equiv\quad & \exists j \geq i \text{ s.t. } \BF{b}^j \models \phi \\
    &\BF{b}^i \models \Always \phi  & \Equiv\quad & \forall j \geq i \text{ s.t. } \BF{b}^j \models \phi
    \end{align*}
    
    \end{definition}



\section{Formal abstractions}
For the sets $A$ and $B$ a relation $\rel\subset A\times B$ is a subset of the Cartesian product $A\times B$. The relation $\rel$ relates $x\in A$ with $y\in B$ if $(x,y)\in\rel$, which is equivalently written as $x\rel y$.
%We use the following notation for the mappings $\rel(\tilde A):=\{y: x\rel y,\  x\in \tilde A\}$ and $\rel^{-1}(\tilde B):=\{x: x\rel y,\  y\in \tilde B\}$  for $\tilde A\subseteq A$ and $\tilde B\subseteq B$.
For a given set $\Y$ a metric or distance function $\mathbf d_\Y$ is a function $\mathbf{d}_\Y: \Y\times \Y\rightarrow \mathbb R_{\ge 0}$ 
satisfying the following conditions: 
$\forall y_1,y_2,y_3\in\Y$:
$\mathbf d_\Y(y_1,y_2)=0$ iff $y_1=y_2$; 
$\mathbf d_\Y(y_1,y_2)=\mathbf d_{\Y}(y_2,y_1)$;  and
$\mathbf d_\Y(y_1,y_3)\leq \mathbf d_\Y(y_1,y_2) +\mathbf d_\Y(y_2,y_3)$. 
 
 

	\bibliographystyle{plain}
	\bibliography{AliAgha,references}

\end{document}

